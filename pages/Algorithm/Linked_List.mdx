## Linked List

- 파이썬에서는 Array List 구현이 잘되어 있어서 잘 가져다 썼지만 이번엔 직접 구현해보는것이 중요.!

> Linked List는 노드라는 구조체가 연결되어 있는 형태다. 노드는 데이터 값과 다음 노드의 주소값을 저장한다. Linked List는 메모리상에서 비연속적으로 저장이 되어있지만
> 각각의 노드가 다음 노드의 메모리 주소값을 가리킴으로써 논리적인 연속성을 갖게 됩니다.

![](https://velog.velcdn.com/images/ghwns1007/post/5149ec3d-4362-432c-902b-03e3d3a16f54/image.png)

### 연결 리스트는 물리적으로 비연속적, 논리적으로는 연속적이다.

> 각 노드들은 데이터를 저장할 뿐만 아니라, 다음 노드의 주소 정보도 가지고 있기 때문에 논리적으로 연속성을 유지하면서 연결될 수 있습니다. 배열의 경우 연속성을 유지하기 위해서
> 메모리 상에서 순차적으로 데이터를 저장하는 방식을 사용하였지만, Linked List에는 메모리상에서 연속성을 유지하지 않아도 되기 때문에 메모리 사용이 좀 더 자유롭다.
> 다만 다음 노드의 주소도 추가적으로 저장해야 하기 때문에 데이터 하나당 차지해야 되는 메모리도 커진다.

## 그렇다면 연결리스트의 노드를 구현해보자

```python
class Node :
  def __init__(self,value=0,next=None):
    self.value = value
    self.next = next

first = Node(1)
second = Node(2)
third = Node(3)

first.next = second
second.next= third
first.value = 6
```

![](https://velog.velcdn.com/images/ghwns1007/post/105153f2-b214-4d78-aa2e-942b81f52246/image.png)

## 그렇다면 구현한 노드들로 Linked List를 만들어보자

- 실제 연결리스트는 헤드값을 가지고 헤드는 첫번째 노드의 주소를 가리켜야 한다.
- 완벽하지는 않지만 우선 작동원리만 보자.

```python
class Node :
  def __init__(self,value=0,next=None):
    self.value = value
    self.next = next

class LinkedList(object):
  def __init__(self):
    self.head = None
  def append(self,value):
    new_node = Node(value)
    if self.head is None:
      self.head = new_node
    # 맨 뒤의 노드가 새로운 노드를 가리켜야 한다.
    else:
      current = self.head
      while(current.next):
        current = current.next
      current.next= new_node

```
